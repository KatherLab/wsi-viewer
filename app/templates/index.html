<!doctype html>
{% raw %}
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>WSI Browser</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/openseadragon@5.0.1/build/openseadragon/openseadragon.min.js"></script>
  <style>
    :root{
      --bg:#f7f9fc; --panel:#ffffff; --muted:#6b7280;
      --border:#e5e7eb; --accent:#2563eb; --chip:#f3f4f6;
      --shadow:0 6px 20px rgba(0,0,0,.06), 0 2px 6px rgba(0,0,0,.05);
      --radius:12px; --danger:#ef4444; --selected:#e0e7ff;
    }
    *{box-sizing:border-box}
    html,body,#app{height:100%;margin:0}
    body{background:var(--bg);color:#111827;font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif}

    header{position:sticky;top:0;z-index:100;padding:12px 16px;border-bottom:1px solid var(--border);display:flex;align-items:center;gap:12px;background:#fff;box-shadow:0 2px 4px rgba(0,0,0,.03)}
    .brand{display:flex;align-items:center;gap:10px}
    .brand img{height:28px;width:auto}
    .brand-text{font-weight:700;color:var(--accent);letter-spacing:.2px}

    .container{display:grid;grid-template-columns:290px 1fr;height:calc(100% - 54px)}
    aside{border-right:1px solid var(--border);overflow:auto;background:var(--chip)}
    main{min-height:0;display:flex;flex-direction:column;position:relative}

    /* Search */
    .search{padding:12px}
    .search input{width:100%;padding:10px 12px;border-radius:10px;border:1px solid var(--border);background:#fff;color:#111827;outline:none}

    /* Tree */
    .tree{padding:8px}
    .dir{padding:8px 10px;border-radius:10px;cursor:pointer;display:flex;justify-content:space-between;align-items:center;transition:all .15s;margin-bottom:2px}
    .dir:hover{background:#eef2f7}
    .dir.selected{background:var(--selected);border:1px solid var(--accent);font-weight:500}
    .dir .right{display:flex;align-items:center;gap:8px}
    .children{padding-left:12px;border-left:1px dashed #cbd5e1;margin-left:6px}

    /* Browser controls */
    .browser-controls{padding:12px 14px;background:#fff;border-bottom:1px solid var(--border);display:flex;gap:12px;align-items:center}
    .slide-search{flex:1;position:relative}
    .slide-search input{width:100%;padding:8px 12px 8px 36px;border-radius:8px;border:1px solid var(--border);background:#fff;outline:none}
    .slide-search svg{position:absolute;left:12px;top:50%;transform:translateY(-50%);opacity:0.5}
    .view-toggle{display:flex;gap:4px;background:var(--chip);padding:4px;border-radius:8px}
    .view-btn{padding:6px 10px;border:none;background:transparent;cursor:pointer;border-radius:6px;color:#6b7280;transition:all .15s}
    .view-btn.active{background:#fff;color:#111827;box-shadow:0 1px 3px rgba(0,0,0,.1)}
    .slide-count{color:var(--muted);font-size:0.9rem}
    .loading-badge{background:#fbbf24;color:#92400e;padding:2px 8px;border-radius:999px;font-size:0.75rem;font-weight:600}
    
    /* Grid view */
    .grid-container{flex:1;overflow-y:auto;background:#fff;position:relative}
    .grid{padding:14px;display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:14px;position:relative}
    
    /* List view */
    .list-container{flex:1;overflow-y:auto;background:#fff}
    .list{padding:8px}
    .list-item{display:flex;align-items:center;padding:10px 14px;border:1px solid var(--border);background:#fff;margin-bottom:4px;border-radius:8px;cursor:pointer;transition:all .15s}
    .list-item:hover{background:#f0f2f6;transform:translateX(2px)}
    .list-thumb{width:60px;height:45px;background:#f1f5f9;border-radius:6px;margin-right:14px;overflow:hidden;flex-shrink:0;position:relative}
    .list-thumb img{width:100%;height:100%;object-fit:cover}
    .list-thumb .loading-spinner{position:absolute;inset:0;display:grid;place-items:center;background:rgba(255,255,255,0.9)}
    .list-info{flex:1;min-width:0}
    .list-name{font-weight:500;color:#111827;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .list-meta{display:flex;gap:12px;margin-top:4px;font-size:0.85rem;color:var(--muted)}
    .list-ext{background:#eef2ff;color:#1e3a8a;padding:2px 6px;border-radius:4px;font-size:0.75rem}

    /* Card styles */
    .card{background:var(--panel);border:1px solid var(--border);border-radius:var(--radius);cursor:pointer;overflow:hidden;box-shadow:var(--shadow);transition:transform .12s, box-shadow .12s;position:relative}
    .card:hover{transform:translateY(-1px);box-shadow:0 10px 28px rgba(0,0,0,.08)}
    .card.loading .thumb{background:#f3f4f6}
    .card.loading .thumb::after{
      content:'';position:absolute;inset:0;
      background:linear-gradient(90deg,transparent,rgba(255,255,255,0.5),transparent);
      animation:shimmer 1.5s infinite;
    }
    @keyframes shimmer{0%{transform:translateX(-100%)}100%{transform:translateX(100%)}}
    .thumb{width:100%;height:180px;background:#f1f5f9;display:grid;place-items:center;position:relative;overflow:hidden}
    .thumb img{width:100%;height:100%;object-fit:contain;background:#fff}
    .thumb .fallback{position:absolute;inset:0;display:grid;place-items:center}
    .meta{padding:10px 12px;font-size:.9rem;color:#374151}
    .meta-row{display:flex;justify-content:space-between;align-items:center;margin-bottom:4px}
    .filename{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-weight:500}
    .filesize{color:var(--muted);font-size:0.85rem}
    .ext-pill{font-size:.72rem;background:#eef2ff;color:#1e3a8a;padding:2px 8px;border-radius:999px;border:1px solid #c7d2fe}

    /* Pagination */
    .pagination{padding:12px 14px;background:#fff;border-top:1px solid var(--border);display:flex;justify-content:center;align-items:center;gap:8px}
    .page-btn{padding:6px 12px;border:1px solid var(--border);background:#fff;border-radius:6px;cursor:pointer;transition:all .15s;min-width:36px;text-align:center}
    .page-btn:hover:not(:disabled){background:var(--chip)}
    .page-btn.active{background:var(--accent);color:#fff;border-color:var(--accent)}
    .page-btn:disabled{opacity:0.5;cursor:not-allowed}
    .page-info{color:var(--muted);padding:0 12px}

    /* Viewer */
    #viewer{position:relative;background:#fff;min-height:0;display:grid;grid-template-columns:1fr 320px;flex:1}
    #viewer.no-sidebar{grid-template-columns:1fr}
    #osd-container{position:relative;background:#fff}
    #osd{position:absolute;inset:0;background:#fff}
    canvas.overlay{position:absolute;inset:0;pointer-events:none;z-index:10}

    /* Back button */
    .back-btn{position:absolute;top:16px;left:16px;z-index:20;width:44px;height:44px;border-radius:50%;border:1px solid var(--border);background:rgba(255,255,255,.98);color:#111827;cursor:pointer;display:grid;place-items:center;box-shadow:var(--shadow);transition:all .2s}
    .back-btn:hover{background:#f3f4f6;transform:scale(1.05)}

    /* Sidebar */
    .sidebar{background:var(--panel);border-left:1px solid var(--border);overflow-y:auto;padding:20px;display:flex;flex-direction:column;gap:20px}
    .sidebar h3{margin:0;font-size:1.1rem;color:#111827}
    .info-section{background:var(--chip);border-radius:10px;padding:14px}
    .info-row{display:flex;justify-content:space-between;padding:6px 0;border-bottom:1px solid var(--border)}
    .info-row:last-child{border-bottom:none}
    .info-label{color:var(--muted);font-size:0.9rem}
    .info-value{color:#111827;font-weight:500;font-size:0.9rem;text-align:right;max-width:60%;word-break:break-word}
    .label-image{width:100%;border-radius:8px;margin-top:10px;cursor:pointer}
    .toggle-sidebar{position:absolute;top:16px;right:16px;z-index:20;width:36px;height:36px;border-radius:8px;border:1px solid var(--border);background:rgba(255,255,255,.98);cursor:pointer;display:grid;place-items:center}

    /* Toolbar */
    .toolbar{position:absolute;left:50%;bottom:16px;transform:translateX(-50%);display:flex;gap:.5rem;background:rgba(255,255,255,.98);border:1px solid var(--border);border-radius:999px;padding:.35rem .5rem;box-shadow:var(--shadow);z-index:15}
    .tb-btn{width:36px;height:36px;border-radius:50%;border:1px solid var(--border);background:#fff;color:#111827;cursor:pointer;display:grid;place-items:center;transition:all .15s}
    .tb-btn:hover{background:#f3f4f6}
    .tb-sep{width:1px;background:var(--border);margin:0 4px}

    /* Empty state */
    .empty{color:var(--muted);display:flex;align-items:center;justify-content:center;height:100%;flex-direction:column;gap:12px}

    /* Layout modes */
    .mode-grid main{grid-template-rows:1fr}
    .mode-viewer main{grid-template-rows:1fr}

    /* Side-menu resolution warning (full-width, left-aligned) */
    .warnline {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      margin-top: 6px;
      background: #fef3c7;      /* amber-50 */
      color: #92400e;            /* amber-900 */
      border: 1px solid #f59e0b; /* amber-500 */
      border-radius: 6px;
      padding: 6px 8px;
      font-size: 12px;
      line-height: 1.3;
      max-width: 100%;
      word-wrap: break-word;
    }

    .warnline svg {
      flex: 0 0 auto;
      margin-top: 1px;
    }

    .warntext {
      white-space: normal; /* allow wrapping across the available width */
    }



    .warn svg {
      flex: 0 0 auto;
    }

    .warn:hover .tip {
      visibility: visible;
      opacity: 1;
    }



    /* Fullscreen adjustments */
    #viewer:-webkit-full-screen .toolbar,
    #viewer:-webkit-full-screen .back-btn,
    #viewer:-webkit-full-screen .toggle-sidebar,
    #viewer:-webkit-full-screen canvas.overlay,
    #viewer:fullscreen .toolbar,
    #viewer:fullscreen .back-btn,
    #viewer:fullscreen .toggle-sidebar,
    #viewer:fullscreen canvas.overlay{
      display:flex !important;
      visibility:visible !important;
    }

    /* Debug panel */
    .debug-panel{position:fixed;bottom:10px;right:10px;background:rgba(0,0,0,0.8);color:#fff;padding:8px 12px;border-radius:8px;font-size:0.75rem;font-family:monospace;z-index:1000;display:none}
    .debug-panel.show{display:block}
  </style>
</head>
<body>
<div id="app" :class="modeClass">
  <header>
    <div class="brand">
      <img src="/logo" alt="Logo">
      <span class="brand-text">WSI Browser</span>
    </div>
    <div style="flex:1"></div>
    <span v-if="activeRequests > 0" class="loading-badge">{{ activeRequests }} loading</span>
  </header>

  <div class="container">
    <!-- LEFT: File tree -->
    <aside>
      <div class="search">
        <input v-model="q" placeholder="Filter folders…" aria-label="Filter folders"/>
      </div>
      <div class="tree">
        <folder v-for="t in filteredTrees" :key="t.id" :node="t" :selected-path="selectedPath" @select-dir="selectDir"></folder>
      </div>
    </aside>

    <!-- RIGHT: Grid/List OR Viewer -->
    <main>
      <template v-if="!current">
        <!-- Browser controls -->
        <div class="browser-controls">
          <div class="slide-search">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="11" cy="11" r="8"></circle>
              <path d="m21 21-4.35-4.35"></path>
            </svg>
            <input v-model="slideSearch" placeholder="Search slides..." @input="filterSlides">
          </div>
          
          <div class="view-toggle">
            <button class="view-btn" :class="{active: viewMode === 'grid'}" @click="switchViewMode('grid')">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="7" height="7"></rect>
                <rect x="14" y="3" width="7" height="7"></rect>
                <rect x="3" y="14" width="7" height="7"></rect>
                <rect x="14" y="14" width="7" height="7"></rect>
              </svg>
            </button>
            <button class="view-btn" :class="{active: viewMode === 'list'}" @click="switchViewMode('list')">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="8" y1="6" x2="21" y2="6"></line>
                <line x1="8" y1="12" x2="21" y2="12"></line>
                <line x1="8" y1="18" x2="21" y2="18"></line>
                <line x1="3" y1="6" x2="3.01" y2="6"></line>
                <line x1="3" y1="12" x2="3.01" y2="12"></line>
                <line x1="3" y1="18" x2="3.01" y2="18"></line>
              </svg>
            </button>
          </div>
          
          <div class="slide-count">
            {{ filteredSlides.length }} {{ filteredSlides.length === 1 ? 'slide' : 'slides' }}
            <span v-if="slideSearch">(filtered)</span>
          </div>
        </div>

        <!-- Grid view -->
        <div v-if="viewMode === 'grid'" class="grid-container" @scroll="handleScroll" ref="gridContainer">
          <div class="grid">
            <div v-for="s in visibleSlides" 
                 :key="s.id" 
                 class="card" 
                 :class="{loading: s.loading}"
                 @click="view(s.id)" 
                 :title="s.name"
                 :data-slide-id="s.id"
                 v-observe-visible>
              <div class="thumb">
                <img v-if="s.thumbUrl" 
                     :src="s.thumbUrl" 
                     alt="preview"
                     loading="lazy"/>
                <div v-else class="fallback" aria-hidden="true">
                  <svg width="56" height="56" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="opacity:.6">
                    <rect x="3" y="3" width="18" height="14" rx="2" ry="2"></rect>
                    <circle cx="8.5" cy="8.5" r="1.5"></circle>
                    <path d="M21 20l-5.5-5.5a2 2 0 0 0-2.8 0L3 20"></path>
                  </svg>
                </div>
              </div>
              <div class="meta">
                <div class="meta-row">
                  <span class="filename" :title="s.name">{{ baseName(s.name) }}</span>
                  <span class="ext-pill">{{ extUpper(s.name) }}</span>
                </div>
                <div class="meta-row">
                  <span class="filesize">{{ prettySize(s.size) }}</span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- List view -->
        <div v-if="viewMode === 'list'" class="list-container">
          <div class="list">
            <div v-for="s in paginatedSlides" 
                 :key="s.id" 
                 class="list-item" 
                 @click="view(s.id)"
                 :data-slide-id="s.id">
              <div class="list-thumb">
                <div v-if="s.loading" class="loading-spinner">⟳</div>
                <img v-else-if="s.thumbUrl" 
                     :src="s.thumbUrl" 
                     alt="preview"/>
              </div>
              <div class="list-info">
                <div class="list-name" :title="s.name">{{ s.name }}</div>
                <div class="list-meta">
                  <span>{{ prettySize(s.size) }}</span>
                  <span>{{ formatDate(s.mtime) }}</span>
                  <span class="list-ext">{{ extUpper(s.name) }}</span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Pagination for list view -->
        <div v-if="viewMode === 'list' && totalPages > 1" class="pagination">
          <button class="page-btn" @click="goToPage(1)" :disabled="currentPage === 1">«</button>
          <button class="page-btn" @click="goToPage(currentPage-1)" :disabled="currentPage === 1">‹</button>
          
          <template v-for="p in pageNumbers">
            <button v-if="p !== '...'" 
                    class="page-btn" 
                    :class="{active: p === currentPage}"
                    @click="goToPage(p)">{{ p }}</button>
            <span v-else class="page-info">...</span>
          </template>
          
          <button class="page-btn" @click="goToPage(currentPage+1)" :disabled="currentPage === totalPages">›</button>
          <button class="page-btn" @click="goToPage(totalPages)" :disabled="currentPage === totalPages">»</button>
          
          <span class="page-info">Page {{ currentPage }} of {{ totalPages }}</span>
        </div>

        <!-- Empty state -->
        <div v-if="!filteredSlides.length" class="empty">
          <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="opacity:.4">
            <path d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"></path>
          </svg>
          <span v-if="!slides.length">Select a folder containing slides</span>
          <span v-else>No slides match your search</span>
        </div>
      </template>

      <!-- Viewer -->
      <section id="viewer" v-else :class="{'no-sidebar': !showSidebar}">
        <div id="osd-container">
          <div id="osd" aria-label="Slide viewer"></div>
          <canvas id="ruler" class="overlay" v-show="hasScale"></canvas>
          
          <!-- Back button -->
          <button class="back-btn" @click="closeViewer" title="Back to grid" aria-label="Back to grid">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M19 12H5M12 19l-7-7 7-7"/>
            </svg>
          </button>

          <!-- Toggle sidebar button -->
          <button class="toggle-sidebar" @click="showSidebar = !showSidebar" title="Toggle info panel">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
              <line x1="9" y1="3" x2="9" y2="21"></line>
            </svg>
          </button>

          <div class="toolbar" v-if="osd">
            <button class="tb-btn" @click="osd.viewport.zoomBy(1/1.2)" title="Zoom out">−</button>
            <button class="tb-btn" @click="osd.viewport.zoomBy(1.2)" title="Zoom in">+</button>
            <div class="tb-sep"></div>
            <button class="tb-btn" @click="resetView" title="Reset view">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 3-6.7"/><path d="M3 3v6h6"/></svg>
            </button>
            <button class="tb-btn" @click="fitWidth" title="Fit to width">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 7h18"/><path d="M8 3l-4 4 4 4"/><path d="M16 3l4 4-4 4"/></svg>
            </button>
            <div class="tb-sep"></div>
            <button class="tb-btn" @click="toggleFS" :title="isFullscreen ? 'Exit fullscreen' : 'Full screen'">
              <svg v-if="!isFullscreen" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M8 3H5a2 2 0 00-2 2v3m18 0V5a2 2 0 00-2-2h-3m0 18h3a2 2 0 002-2v-3M3 16v3a2 2 0 002 2h3"/>
              </svg>
              <svg v-else width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M8 3v3a2 2 0 01-2 2H3m18 0h-3a2 2 0 01-2-2V3m0 18v-3a2 2 0 012-2h3M3 16h3a2 2 0 012 2v3"/>
              </svg>
            </button>
          </div>
        </div>

        <!-- Sidebar -->
        <aside class="sidebar" v-if="showSidebar && slideMeta">
          <h3>Slide Information</h3>
          
          <div class="info-section">
            <div class="info-row">
              <span class="info-label">Filename</span>
              <span class="info-value" :title="slideMeta.name">{{ slideMeta.name }}</span>
            </div>
            <div class="info-row">
              <span class="info-label">Dimensions</span>
              <span class="info-value">{{ slideMeta.width }} × {{ slideMeta.height }}</span>
            </div>
            <div class="info-row" v-if="slideMeta.vendor">
              <span class="info-label">Scanner</span>
              <span class="info-value">{{ slideMeta.vendor }}</span>
            </div>
            <div class="info-row" v-if="slideMeta.objective_power">
              <span class="info-label">Objective</span>
              <span class="info-value">{{ slideMeta.objective_power }}×</span>
            </div>
            <div class="info-row" v-if="slideMeta.mpp_x">
              <span class="info-label">Resolution</span>
              <span class="info-value">
                {{ slideMeta.mpp_x.toFixed(3) }} µm/px
                <div v-if="resolutionSuspect" class="warnline" :title="resolutionWarning">
                  <!-- Warning icon -->
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none"
                      stroke="currentColor" stroke-width="2" style="color:#d97706">
                    <path d="M10.29 3.86 1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/>
                    <line x1="12" y1="9" x2="12" y2="13"/>
                    <line x1="12" y1="17" x2="12.01" y2="17"/>
                  </svg>
                  <span class="warntext">{{ resolutionWarning }}</span>
                </div>
              </span>
            </div>
            <div class="info-row">
              <span class="info-label">Levels</span>
              <span class="info-value">{{ slideMeta.level_count }}</span>
            </div>
            <div class="info-row" v-if="!slideMeta.mpp_x">
              <span class="info-label">Resolution</span>
              <span class="info-value">
                Unknown
                <div class="warnline" title="No microns-per-pixel in metadata; scale bar disabled.">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none"
                      stroke="currentColor" stroke-width="2" style="color:#6b7280">
                    <circle cx="12" cy="12" r="10"/>
                    <line x1="12" y1="8" x2="12" y2="12"/>
                    <line x1="12" y1="16" x2="12.01" y2="16"/>
                  </svg>
                  <span class="warntext">No scale found in metadata; the ruler is hidden.</span>
                </div>
              </span>
            </div>
            <div class="info-row" v-if="slideMeta.file_size">
              <span class="info-label">File size</span>
              <span class="info-value">{{ prettySize(slideMeta.file_size) }}</span>
            </div>
          </div>

          <div class="info-section" v-if="associatedImages && associatedImages.length">
            <h3>Associated Images</h3>
            <div v-for="img in associatedImages" :key="img.name" style="margin-bottom:10px">
              <div style="font-size:0.9rem;color:var(--muted);margin-bottom:4px">{{ img.name }}</div>
              <img :src="img.url" :alt="img.name" class="label-image" @click="viewFullImage(img.url)"/>
            </div>
          </div>
        </aside>
      </section>
    </main>
  </div>

  <!-- Debug panel -->
  <div class="debug-panel" :class="{show: debug}">
    Active: {{ activeRequests }}<br>
    Queue: {{ requestQueue.length }}<br>
    Visible: {{ visibleRange.start }}-{{ visibleRange.end }}
  </div>
</div>

<script>
const { createApp } = Vue;

// Folder component
const Folder = {  
  name: 'Folder',
  props: ["node", "selectedPath"],
  emits: ["select-dir"],
  data(){ 
    return { 
      open: false,
      loading: false,
      childrenLoaded: false,
      localChildren: null
    } 
  },
  methods:{
    async toggle(){ 
      if (!this.open && !this.childrenLoaded && this.node.has_children) {
        this.loading = true;
        try {
          const response = await fetch('/api/expand?' + new URLSearchParams({path: this.node.path}));
          if (response.ok) {
            this.localChildren = await response.json();
            this.childrenLoaded = true;
          }
        } catch (e) {
          console.error('Failed to load children:', e);
        } finally {
          this.loading = false;
        }
      }
      
      this.open = !this.open;
      this.$emit("select-dir", this.node.path);
    }
  },
  computed:{ 
    hasChildren(){ 
      return this.node.has_children || (this.node.children && this.node.children.length > 0);
    },
    children() {
      return this.localChildren || this.node.children || [];
    },
    isSelected(){ 
      return this.selectedPath === this.node.path;
    },
    slideCountText() {
      if (!this.node.slide_count || this.node.slide_count === 0) return '';
      return this.node.slide_count === 1 ? '1 slide' : `${this.node.slide_count} slides`;
    }
  },
  template:`
    <div>
      <div class="dir" @click="toggle" :aria-expanded="open" :class="{selected: isSelected}">
        <div>
          <strong>{{ node.name }}</strong>
          <small v-if="slideCountText" style="color:var(--muted)"> · {{ slideCountText }}</small>
          <span v-if="loading" style="margin-left:8px;color:var(--muted)">(loading...)</span>
        </div>
        <div class="right">
          <span v-if="hasChildren" style="color:var(--muted)">{{ open ? "▾" : "▸" }}</span>
        </div>
      </div>
      <div class="children" v-if="open && children.length > 0">
        <folder v-for="c in children" :key="c.id" :node="c" :selected-path="selectedPath" @select-dir="$emit('select-dir',$event)"></folder>
      </div>
    </div>`
}

// Custom directive to hook IntersectionObserver to grid cards
const observeVisibleDirective = {
  mounted(el, binding) {
    const vm = binding.instance;
    if (!vm.viewportObserver) {
      vm._toObserve.push(el);
      return;
    }
    vm.viewportObserver.observe(el);
  },
  updated(el, binding) {
    const vm = binding.instance;
    if (vm && vm.viewportObserver) {
      vm.viewportObserver.observe(el);
    }
  },
  unmounted(el, binding) {
    const vm = binding.instance;
    if (vm && vm.viewportObserver) {
      vm.viewportObserver.unobserve(el);
    }
  }
};


// Main app
const app = createApp({
  components:{ Folder },
  data(){ 
    return { 
      // Tree & navigation
      trees:[], 
      q:"", 
      selectedPath:null,
      
      // Slides
      slides:[],
      filteredSlides:[],
      visibleSlides:[],
      slideSearch:"",
      
      // View modes
      viewMode:'grid',
      currentPage:1,
      itemsPerPage:50,
      
      // Viewer
      osd:null, 
      current:null, 
      mpp:null,
      hasScale:false, 
      showSidebar:true,
      slideMeta:null,
      associatedImages:[],
      
      // UI state
      isFullscreen:false,
      logoUrl:null,
      debug:false,
      
      // Request management - critical for performance
      activeRequests:0,
      pendingRequests: new Map(),
      requestQueue: [],
      maxConcurrentThumbs: 2, // kept for debug badge; not used after queueing
      loadingSlides: new Set(),
      
      // Thumbnail queue/concurrency control
      thumbSlots: 4,
      thumbInFlight: 0,
      thumbQueue: [], // [{ slide, priority }]
      
      // Viewport tracking
      visibleRange:{start:0, end:0},
      lastScrollTime:0,
      scrollDebounceTimer:null,
      viewportObserver:null,

      // Elements awaiting observer creation
      _toObserve: []
    } 
  },
  
  computed:{
    resolutionSuspect(){
      // Guard: need metadata available
      const m = this.slideMeta;
      if (!m || !Number.isFinite(m?.mpp_x)) return false;

      const x = m.mpp_x;

      // Heuristics for WSI (typical: ~0.25 µm/px @40x; ~0.5 @20x; ~1.0 @10x; ~2.0 @5x)
      // Flag anything clearly out of band:
      //  - absurdly small: < 0.01 µm/px (nanoscale) -> broken
      //  - very large:     > 5 µm/px (unlikely for diagnostic WSI)
      //  - extremely large: > 50 µm/px (definitely broken)
      return (x < 0.01) || (x > 5);
    },
    resolutionWarning(){
      const m = this.slideMeta;
      if (!m || !Number.isFinite(m?.mpp_x)) return "";
      const x = m.mpp_x;

      if (x < 0.01) {
        return `Unrealistic resolution (${x.toFixed(3)} µm/px). Value is too small for WSI — metadata likely incorrect.`;
      }
      if (x > 50) {
        return `Unrealistic resolution (${x.toFixed(3)} µm/px). Value is extremely large — metadata likely incorrect.`;
      }
      if (x > 5) {
        return `Suspicious resolution (${x.toFixed(3)} µm/px). Much larger than typical WSI — metadata may be incorrect.`;
      }
      return "";
    },


    filteredTrees(){
      if(!this.q) return this.trees
      const term = this.q.toLowerCase()
      const match = (n)=> n.name.toLowerCase().includes(term) || (n.children||[]).some(match)
      const clone = (n)=> ({...n, children:(n.children||[]).map(clone).filter(match)})
      return this.trees.map(clone).filter(match)
    },
    
    modeClass(){ return this.current ? 'mode-viewer' : 'mode-grid' },
    
    paginatedSlides(){
      const start = (this.currentPage - 1) * this.itemsPerPage;
      return this.filteredSlides.slice(start, start + this.itemsPerPage);
    },
    
    totalPages(){
      return Math.ceil(this.filteredSlides.length / this.itemsPerPage);
    },
    
    pageNumbers(){
      const pages = [];
      const total = this.totalPages;
      const current = this.currentPage;
      
      if(total <= 7) {
        for(let i = 1; i <= total; i++) pages.push(i);
      } else {
        if(current <= 3) {
          for(let i = 1; i <= 5; i++) pages.push(i);
          pages.push('...');
          pages.push(total);
        } else if(current >= total - 2) {
          pages.push(1);
          pages.push('...');
          for(let i = total - 4; i <= total; i++) pages.push(i);
        } else {
          pages.push(1);
          pages.push('...');
          for(let i = current - 1; i <= current + 1; i++) pages.push(i);
          pages.push('...');
          pages.push(total);
        }
      }
      return pages;
    }
  },
  
  methods:{
    // Utility methods
    prettySize(b){ 
      if(!b && b!==0) return ""; 
      const u=["B","KB","MB","GB","TB"]; 
      let i=0; 
      while(b>1024 && i<u.length-1){ b/=1024; i++ } 
      return b.toFixed(b<10 && i>0 ? 1 : 0) + " " + u[i] 
    },
    baseName(name){ const i=name.lastIndexOf("."); return i>0 ? name.slice(0,i) : name },
    extName(name){ const i=name.lastIndexOf("."); return i>0 ? name.slice(i+1) : "" },
    extUpper(name){ return this.extName(name).toUpperCase() },
    formatDate(ts){ 
      if(!ts) return "";
      const d = new Date(ts * 1000);
      return d.toLocaleDateString('en-US', {year:'numeric', month:'short', day:'numeric'});
    },

    ensureObserver() {
      // Rebuild the IntersectionObserver with the CURRENT grid root
      if (this.viewportObserver) {
        try { this.viewportObserver.disconnect(); } catch(e) {}
        this.viewportObserver = null;
      }
      const root = this.$refs.gridContainer || null;

      if ('IntersectionObserver' in window) {
        this.viewportObserver = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              const slideId = entry.target.dataset.slideId;
              const slide = this.visibleSlides.find(s => s.id === slideId);
              if (slide && !slide.thumbUrl && !slide.thumbError) {
                this.loadThumbnail(slide);
              }
            }
          });
        }, {
          root,
          rootMargin: '200px',
          threshold: 0.01,
        });

        if (this._toObserve.length) {
          this._toObserve.forEach(el => this.viewportObserver.observe(el));
          this._toObserve = [];
        }
      }
    },

    // Critical: Request management
    async makeRequest(url, priority = 0) {
      const controller = new AbortController();
      const requestId = Math.random().toString(36);
      
      this.pendingRequests.set(requestId, {controller, priority, url});
      this.activeRequests++;
      
      try {
        const response = await fetch(url, {
          signal: controller.signal,
          headers: {'X-Priority': priority.toString()}
        });
        return response;
      } finally {
        this.pendingRequests.delete(requestId);
        this.activeRequests--;
      }
    },
    
    cancelAllRequests() {
      for (const [id, req] of this.pendingRequests) {
        req.controller.abort();
      }
      this.pendingRequests.clear();
      this.requestQueue = [];
      this.loadingSlides.clear();
      this.activeRequests = 0;

      // Also clear queued thumbs and reset counters to avoid a stuck queue
      this.thumbQueue = [];
      this.thumbInFlight = 0; // <— important reset
    },

    
    cancelRequestsOutsideViewport() {
      // Cancel requests for items not in current viewport
      const inViewport = new Set(
        this.visibleSlides
          .slice(this.visibleRange.start, this.visibleRange.end)
          .map(s => s.id)
      );
      
      for (const [id, req] of this.pendingRequests) {
        if (req.url.includes('/api/thumb/')) {
          const slideId = req.url.split('/api/thumb/')[1];
          if (!inViewport.has(slideId)) {
            req.controller.abort();
            this.pendingRequests.delete(id);
            this.loadingSlides.delete(slideId);
          }
        }
      }
    },

    // Blob URL cleanup
    revokeThumb(slide){
      if (slide && slide.thumbUrl) {
        URL.revokeObjectURL(slide.thumbUrl);
        slide.thumbUrl = null;
      }
    },

    // Thumbnail loading with a queue + strict viewport priority
    loadThumbnail(slide) {
      if (!slide || slide.thumbUrl || slide.thumbError || this.loadingSlides.has(slide.id)) return;
      // priority based on distance to viewport center
      const slideIndex = this.visibleSlides.indexOf(slide);
      const viewportCenter = (this.visibleRange.start + this.visibleRange.end) / 2;
      const distance = Math.abs(slideIndex - viewportCenter);
      const priority = Math.max(0, 1000 - distance * 10);

      // enqueue
      this.thumbQueue.push({ slide, priority });
      // highest priority first
      this.thumbQueue.sort((a,b) => b.priority - a.priority);
      this._drainThumbQueue();
    },

    async _drainThumbQueue() {
      while (this.thumbInFlight < this.thumbSlots && this.thumbQueue.length) {
        const { slide, priority } = this.thumbQueue.shift();
        this._fetchThumb(slide, priority).catch(()=>{});
      }
    },

    async _fetchThumb(slide, priority) {
      if (!slide || slide.thumbUrl || slide.thumbError || this.loadingSlides.has(slide.id)) return;
      this.loadingSlides.add(slide.id);
      slide.loading = true;
      this.thumbInFlight++;

      const controller = new AbortController();
      const requestId = `thumb-${slide.id}`;
      this.pendingRequests.set(requestId, {controller, priority, url: `/api/thumb/${slide.id}`});

      try {
        const timeoutId = setTimeout(() => controller.abort(), 8000);
        const resp = await fetch(`/api/thumb/${slide.id}`, {
          signal: controller.signal,
          headers: {'X-Priority': String(priority)}
        });
        clearTimeout(timeoutId);

        if (resp.ok) {
          const blob = await resp.blob();
          this.revokeThumb(slide);
          slide.thumbUrl = URL.createObjectURL(blob);
        } else {
          slide.thumbError = true;
        }
      } catch (e) {
        if (e.name !== 'AbortError') {
          slide.thumbError = true;
        }
      } finally {
        slide.loading = false;
        this.pendingRequests.delete(requestId);
        this.loadingSlides.delete(slide.id);
        this.thumbInFlight = Math.max(0, this.thumbInFlight - 1); // clamp so it never goes negative
        this._drainThumbQueue();
      }
    },

    // Smart viewport-based loading
    updateViewport() {
      if (this.viewMode !== 'grid' || !this.$refs.gridContainer) return;
      
      const container = this.$refs.gridContainer;
      const scrollTop = container.scrollTop;
      const clientHeight = container.clientHeight;
      
      // Calculate visible range
      const itemsPerRow = Math.floor(container.clientWidth / 260) || 4;
      const rowHeight = 280;
      const firstRow = Math.floor(scrollTop / rowHeight);
      const lastRow = Math.ceil((scrollTop + clientHeight) / rowHeight);
      
      const newStart = Math.max(0, firstRow * itemsPerRow);
      const newEnd = Math.min(this.visibleSlides.length, (lastRow + 1) * itemsPerRow);
      
      // Only update if range changed significantly
      if (Math.abs(newStart - this.visibleRange.start) > 2 || 
          Math.abs(newEnd - this.visibleRange.end) > 2) {
        this.visibleRange = {start: newStart, end: newEnd};
        
        // Cancel requests outside new viewport
        this.cancelRequestsOutsideViewport();
        
        // Hint-load the currently visible thumbnails (IntersectionObserver will also trigger)
        for (let i = newStart; i < newEnd; i++) {
          const slide = this.visibleSlides[i];
          if (slide && !slide.thumbUrl && !slide.thumbError) {
            this.loadThumbnail(slide);
          }
        }
      }
    },

    handleScroll(event) {
      if (this.viewMode !== 'grid') return;
      
      // Immediate viewport update
      this.updateViewport();
      
      // Debounced actions
      if (this.scrollDebounceTimer) {
        clearTimeout(this.scrollDebounceTimer);
      }
      
      this.scrollDebounceTimer = setTimeout(() => {
        const container = event.target;
        const scrollHeight = container.scrollHeight;
        const scrollTop = container.scrollTop;
        const clientHeight = container.clientHeight;
        
        // Load more slides if near bottom
        if (scrollTop + clientHeight > scrollHeight - 200) {
          this.loadMoreSlides();
        }
      }, 100);
    },

    // Data loading
    async loadTrees(){ 
      try {
        const response = await this.makeRequest("/api/tree");
        if (response.ok) {
          this.trees = await response.json();
        }
      } catch (e) {
        console.error('Failed to load trees:', e);
      }
    },
    
    selectDir(path){
      // free blobs before switching
      this.visibleSlides.forEach(s => this.revokeThumb(s));
      this.cancelAllRequests(); // Cancel everything when changing dirs
      this.selectedPath = path;
      this.openDir(path);
    },
    
    async openDir(path){ 
      this.cancelAllRequests();
      this.current = null;
      // free existing blobs and reset
      this.visibleSlides.forEach(s => this.revokeThumb(s));
      this.visibleSlides = [];
      
      try {
        const response = await this.makeRequest("/api/dir?" + new URLSearchParams({path}));
        if (response.ok) {
          this.slides = await response.json();
          this.filteredSlides = [...this.slides];
          this.currentPage = 1;
          this.slideSearch = "";
          this.initializeView();
        }
      } catch (e) {
        if (e.name !== 'AbortError') {
          console.error('Failed to load directory:', e);
        }
      }
    },
    
    filterSlides(){
      this.cancelAllRequests();
      // revoke previous page blobs
      this.visibleSlides.forEach(s => this.revokeThumb(s));
      const term = this.slideSearch.toLowerCase();
      if(!term) {
        this.filteredSlides = [...this.slides];
      } else {
        this.filteredSlides = this.slides.filter(s => 
          s.name.toLowerCase().includes(term)
        );
      }
      this.currentPage = 1;
      this.initializeView();
    },
    
    initializeView(){
      if (this.viewMode === 'grid') {
        // Rebuild slide list
        this.visibleSlides = this.filteredSlides.map(s => ({
          ...s,
          loading: false,
          thumbUrl: null,
          thumbError: false
        }));

        // Do the work after DOM is rendered
        this.$nextTick(async () => {
          const ok = await this.waitForGridRoot();
          if (!ok) {
            console.debug('[WSI] gridContainer ref not ready after retries; forcing prime as fallback');
            this.forcePrimeThumbnails();
            return;
          }

          // Now we definitely have the current grid root
          this.ensureObserver();

          // Two passes: immediate + post-layout
          this.updateViewport();
          setTimeout(() => this.updateViewport(), 0);

          // Safety net: if nothing in flight, prime a few
          if (this.thumbInFlight === 0 && this.pendingRequests.size === 0) {
            this.forcePrimeThumbnails();
          }
        });
      } else {
        // List view - load thumbnails for current page only
        this.$nextTick(() => {
          this.paginatedSlides.forEach(slide => {
            if (!slide.thumbUrl && !slide.thumbError) {
              this.loadThumbnail(slide);
            }
          });
        });
      }
    },

    async waitForGridRoot(retries = 20) {
      // Wait until this.$refs.gridContainer is available after view switches.
      // 20 * 16ms ≈ ~320ms worst-case.
      while (retries-- > 0) {
        await this.$nextTick();
        if (this.$refs.gridContainer) return true;
        await new Promise(r => setTimeout(r, 16));
      }
      return !!this.$refs.gridContainer;
    },

    forcePrimeThumbnails(count = 24) {
      // Fire some initial requests even if the observer or viewport math lags
      const end = Math.min(this.visibleSlides.length, count);
      for (let i = 0; i < end; i++) {
        const s = this.visibleSlides[i];
        if (s && !s.thumbUrl && !s.thumbError) this.loadThumbnail(s);
      }
    },


    loadMoreSlides(){
      // Grid view handles all slides at once
      // Just update viewport
      this.updateViewport();
    },
    
    switchViewMode(mode){
      // revoke existing blobs & cancel in-flight
      this.visibleSlides.forEach(s => this.revokeThumb(s));
      this.cancelAllRequests();
      this.viewMode = mode;
      this.initializeView();
    },

    
    goToPage(page){
      // revoke blobs from current page
      this.paginatedSlides.forEach(s => this.revokeThumb(s));
      this.cancelAllRequests();
      this.currentPage = page;
      this.initializeView();
    },

    // Viewer methods
    async view(id){
      // Cancel thumbnails when opening viewer
      this.cancelAllRequests();
      this.current = id;
      
      try {
        const metaResp = await this.makeRequest("/api/meta/" + id, 1000); // High priority
        if (metaResp.ok) {
          this.slideMeta = await metaResp.json();
          this.hasScale = Number.isFinite(this.slideMeta?.mpp_x) && this.slideMeta.mpp_x > 0;
          this.mpp = this.hasScale ? this.slideMeta.mpp_x : null;
        } else {
          this.hasScale = false;
          this.mpp = null;
        }
      } catch (e) {
        console.error('Failed to load metadata:', e);
        this.hasScale = false;
        this.mpp = null;
      }

      
      this.associatedImages = [];
      
      // Load associated images
      try {
        const assocResp = await this.makeRequest("/api/associated/" + id, 500);
        if(assocResp.ok) {
          const assocList = await assocResp.json();
          this.associatedImages = assocList.map(name => ({
            name: name,
            url: `/api/associated/${id}/${name}`
          }));
        }
      } catch(e) {
        console.log("Could not load associated images:", e);
      }
      
      if(this.osd){ this.osd.destroy(); this.osd=null }
      this.osd = OpenSeadragon({
        id:"osd",
        tileSources:"/dzi/" + id + ".dzi",
        showNavigator:true,
        navigatorPosition: 'BOTTOM_RIGHT',
        navigatorSizeRatio: 0.15,
        showZoomControl:false,
        showHomeControl:false,
        showFullPageControl:false,
        visibilityRatio:1,
        minZoomLevel:0.001,
        maxZoomLevel:40,
        background:"#ffffff",
        maxImageCacheCount: 100,
        imageLoaderLimit: 4
      });

      // Attach the ruler only if slide scale is known
      this.$nextTick(() => {
        const canvas = document.getElementById('ruler');
        if (this.hasScale && this.mpp) {
          canvas && (canvas.style.display = '');
          attachRuler(this.osd, this.mpp);
        } else {
          // ensure overlay is cleared/hidden if no reliable scale
          if (canvas) {
            const ctx = canvas.getContext('2d');
            ctx && ctx.clearRect(0,0,canvas.width,canvas.height);
            canvas.style.display = 'none';
          }
        }
      });
    },
    
    closeViewer(){ 
      this.cancelAllRequests();
      if (this.osd) { this.osd.destroy(); this.osd = null; } 
      this.current = null;
      this.slideMeta = null;
      this.associatedImages = [];
      this.hasScale = false;
      this.mpp = null;

      const canvas = document.getElementById('ruler');
      if (canvas) {
        const ctx = canvas.getContext('2d');
        ctx && ctx.clearRect(0,0,canvas.width,canvas.height);
        canvas.style.display = 'none';
      }

      this.isFullscreen = false;
      if (document.fullscreenElement) {
        document.exitFullscreen();
      }

      // Rebuild grid after the viewer has fully unmounted
      this.$nextTick(async () => {
        // Wait for the grid DOM to exist again
        const ok = await this.waitForGridRoot();
        if (!ok) console.debug('[WSI] gridContainer ref not ready after closing viewer');
        this.initializeView(); // initializeView itself will ensureObserver + updateViewport + prime
      });
    },

    
    resetView(){ 
      if(!this.osd) return; 
      this.osd.viewport.setRotation(0); 
      this.osd.viewport.goHome(true);
    },
    
    fitWidth(){
      if(!this.osd) return;
      const item=this.osd.world.getItemAt(0); 
      if(!item) return;
      const bounds=item.getBounds();
      const vp=this.osd.viewport; 
      const w=bounds.width;
      if(w>0){ 
        const containerAspect=vp.getContainerSize().x/vp.getContainerSize().y; 
        vp.fitBoundsWithConstraints(new OpenSeadragon.Rect(bounds.x, bounds.y, w, w/containerAspect), true);
      }
    },
    
    toggleFS(){ 
      const viewer = document.getElementById('viewer');
      if (!document.fullscreenElement) {
        viewer.requestFullscreen();
        this.isFullscreen = true;
      } else {
        document.exitFullscreen();
        this.isFullscreen = false;
      }
    },
    
    viewFullImage(url){
      window.open(url, '_blank');
    },
  },
  
  mounted(){ 
    this.loadTrees(); 
    
    // Listen for fullscreen changes
    document.addEventListener('fullscreenchange', () => {
      this.isFullscreen = !!document.fullscreenElement;
    });
    
    // Cancel all requests on page unload
    window.addEventListener('beforeunload', () => {
      this.cancelAllRequests();
    });
    
    // Setup IntersectionObserver for grid container
    this.ensureObserver();

    // initial viewport compute
    this.$nextTick(() => this.updateViewport());
  },
  
  beforeUnmount() {
    this.cancelAllRequests();
    if (this.viewportObserver) {
      this.viewportObserver.disconnect();
    }
    // Revoke any allocated blobs
    this.visibleSlides.forEach(s => this.revokeThumb(s));
  }
});
app.directive('observe-visible', observeVisibleDirective);
app.mount("#app")

// Ruler function (with bottom positioning)
function attachRuler(viewer, mppX, opts = {}) {
  const canvas = document.getElementById("ruler");
  const options = {
    targetCssWidth: 220,    // visual bar width (CSS px)
    majorTicks: 3,          // 3 = start–middle–end (use 5 for more)
    tickLenCss: 5,          // short ticks
    barThicknessCss: 2,     // thin baseline
    labelFontSizeCss: 12,
    pillPaddingCss: 12,     // inner padding
    minPillWidthCss: 160,
    // vertical gaps:
    gapLabelToBarCss: 6,    // space between label and baseline
    safeBottomMarginCss: 2, // keep a small gap above the pill bottom
    // visuals:
    pillBgRGBA: "rgba(255,255,255,0.8)",   // ~20% transparent
    pillBorderRGBA: "rgba(17,24,39,0.10)", // subtle border
    strokeRGBA: "#111827",
    ...opts
  };

  function resize() {
    const DPR = window.devicePixelRatio || 1;
    const rect = viewer.element.getBoundingClientRect();
    canvas.width  = Math.floor(rect.width * DPR);
    canvas.height = Math.floor(rect.height * DPR);
    canvas.style.width  = rect.width + "px";
    canvas.style.height = rect.height + "px";
  }

  function nice(v) {
    const p = Math.pow(10, Math.floor(Math.log10(v)));
    const d = v / p;
    const step = d < 2 ? 1 : d < 5 ? 2 : 5;
    return step * p;
  }

  function redraw() {
    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    const DPR = window.devicePixelRatio || 1;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const vp = viewer.viewport;
    const zoom = vp.viewportToImageZoom(vp.getZoom(true));

    // Figure out a "nice" total length for the bar
    const imgPx = options.targetCssWidth / zoom;
    const um = imgPx * mppX;
    const niceUm = nice(um);
    const barCss = (niceUm / mppX) * zoom;
    const barPx  = barCss * DPR;

    const labelText = niceUm >= 1000
      ? `${(niceUm/1000).toFixed(niceUm % 1000 === 0 ? 0 : 1)} mm`
      : `${Math.round(niceUm)} µm`;

    // Layout constants (device px)
    const tickLen = options.tickLenCss * DPR;
    const barTh   = options.barThicknessCss * DPR;
    const pad     = options.pillPaddingCss * DPR;
    const minPillW= options.minPillWidthCss * DPR;
    const gapLbl2Bar = options.gapLabelToBarCss * DPR;
    const safeBottomMargin = options.safeBottomMarginCss * DPR;

    // Measure label width
    const fontPx = options.labelFontSizeCss * DPR;
    ctx.font = `${fontPx}px system-ui,-apple-system,Segoe UI,Roboto,Arial`;
    const labelW = ctx.measureText(labelText).width;

    // Pill sizing
    const pillInnerW = Math.max(labelW, barPx);
    const pillW = Math.max(minPillW, pillInnerW + pad * 2);
    const pillH = Math.max(36 * DPR,                // enough room for label + bar + ticks
                           fontPx + gapLbl2Bar + barTh + tickLen + pad * 2);

    // Place pill near bottom-left (but safely on-screen)
    const screenPad = 12 * DPR;
    let pillX = 30 * DPR;
    let pillY = canvas.height - (100 * DPR) - pillH;
    pillX = Math.max(screenPad, Math.min(pillX, canvas.width  - pillW - screenPad));
    pillY = Math.max(screenPad, Math.min(pillY, canvas.height - pillH - screenPad));

    // Draw pill background with ~20% transparency
    ctx.save();
    const rx = 12 * DPR;
    ctx.fillStyle = options.pillBgRGBA;     // translucent white
    ctx.strokeStyle = options.pillBorderRGBA;
    ctx.lineWidth = 1 * DPR;
    ctx.beginPath();
    ctx.moveTo(pillX + rx, pillY);
    ctx.arcTo(pillX + pillW, pillY, pillX + pillW, pillY + pillH, rx);
    ctx.arcTo(pillX + pillW, pillY + pillH, pillX, pillY + pillH, rx);
    ctx.arcTo(pillX, pillY + pillH, pillX, pillY, rx);
    ctx.arcTo(pillX, pillY, pillX + pillW, pillY, rx);
    ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.restore();

    // Content frame
    const contentX = pillX + (pillW - pillInnerW) / 2;
    const contentTop = pillY + pad;
    const safeTop = pillY + pad;
    const safeBottom = pillY + pillH - pad - safeBottomMargin;

    // Initial vertical positions (raised a bit)
    let labelY = contentTop + fontPx;               // label line
    let yRule  = labelY + gapLbl2Bar + barTh / 2;   // baseline
    let tickBottom = yRule + tickLen;

    // If ticks would hit bottom, shift everything up by the excess
    if (tickBottom > safeBottom) {
      const shiftUp = tickBottom - safeBottom;
      labelY -= shiftUp;
      yRule  -= shiftUp;
      tickBottom -= shiftUp;
    }
    // Ensure we never go above the safe area either
    if (labelY - fontPx < safeTop) {
      const shiftDown = safeTop - (labelY - fontPx);
      labelY += shiftDown;
      yRule  += shiftDown;
    }

    // Center bar horizontally within inner content
    const barX = contentX + (pillInnerW - barPx) / 2;

    // Label (centered)
    ctx.fillStyle = options.strokeRGBA;
    ctx.textBaseline = "alphabetic";
    ctx.fillText(labelText, pillX + pillW / 2 - labelW / 2, labelY);

    // Baseline
    ctx.strokeStyle = options.strokeRGBA;
    ctx.lineWidth = barTh;
    ctx.beginPath();
    ctx.moveTo(barX, yRule);
    ctx.lineTo(barX + barPx, yRule);
    ctx.stroke();

    // Evenly spaced ticks (identical, downward only)
    const ticks = Math.max(2, Math.floor(options.majorTicks));
    const segments = ticks - 1;
    for (let i = 0; i < ticks; i++) {
      const t = i / segments; // 0..1
      const x = barX + t * barPx;
      ctx.beginPath();
      ctx.moveTo(x, yRule);
      ctx.lineTo(x, Math.min(yRule + tickLen, safeBottom)); // clamp just in case
      ctx.stroke();
    }
  }

  function full(){ resize(); redraw(); }
  resize();
  window.addEventListener("resize", full);
  viewer.addHandler("update-viewport", redraw);
  viewer.addHandler("full-screen", () => { setTimeout(full, 100); });
  viewer.addOnceHandler("open", full);

  return { resize, redraw };
}

</script>
</body>
</html>
{% endraw %}
